import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:scalemasterguitar/UI/fretboard/provider/fingerings_provider.dart';
import 'package:scalemasterguitar/UI/fretboard_page/provider/sharp_flat_selection_provider.dart';
import 'package:scalemasterguitar/UI/player_page/logic/sequencer_manager.dart';
import 'package:scalemasterguitar/UI/player_page/player/player_widget.dart';
import 'package:scalemasterguitar/UI/player_page/provider/is_playing_provider.dart';
import 'package:scalemasterguitar/UI/player_page/provider/player_page_title.dart';
import 'package:scalemasterguitar/UI/player_page/provider/selected_chords_provider.dart';
import 'package:scalemasterguitar/widgets/banner_ad_widget.dart';
import 'package:scalemasterguitar/constants/app_theme.dart';

import '../../models/chord_scale_model.dart';
import '../../models/progression_model.dart';
import '../../utils/slide_route.dart';
import '../progression_library/progression_library_page.dart';
import '../chords/chords.dart';
import '../fretboard/UI/fretboard_neck.dart';
import '../fretboard_page/fretboard_page.dart';
import '../fretboard_page/provider/fretboard_page_fingerings_provider.dart';
import '../chromatic_wheel/provider/top_note_provider.dart';
import '../scale_selection_dropdowns/provider/scale_dropdown_value_provider.dart';
import '../scale_selection_dropdowns/provider/mode_dropdown_value_provider.dart';
import '../fretboard/provider/beat_counter_provider.dart';
import '../home_page/selection_page.dart';
import '../paywall/unified_paywall.dart';
import '../../services/feature_restriction_service.dart';
import '../../services/default_progression_generator.dart';

class PlayerPage extends ConsumerWidget {
  final ProgressionModel? initialProgression;
  
  const PlayerPage({super.key, this.initialProgression});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return _PlayerPageContent(initialProgression: initialProgression);
  }
}

class _PlayerPageContent extends ConsumerStatefulWidget {
  final ProgressionModel? initialProgression;
  
  const _PlayerPageContent({super.key, this.initialProgression});
  
  @override
  _PlayerPageContentState createState() => _PlayerPageContentState();
}

class _PlayerPageContentState extends ConsumerState<_PlayerPageContent> {
  bool _isDisposed = false;
  bool _isCleaningUp = false;
  bool _hasAutoGeneratedDefaults = false;
  bool _isPreparingSequence = true;
  bool _isTransitionComplete = false;

  @override
  void initState() {
    super.initState();

    // Defer heavy content build until after the slide transition (300ms) finishes.
    // This keeps the animation smooth — only the lightweight overlay renders during it.
    Future.delayed(const Duration(milliseconds: 350), () {
      if (!mounted) return;
      setState(() { _isTransitionComplete = true; });
    });

    // Load initial progression if provided
    if (widget.initialProgression != null) {
      _hasAutoGeneratedDefaults = true; // Skip auto-generation for saved progressions
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        await _loadProgression(widget.initialProgression!);
      });
    }
  }

  /// Auto-generates a default chord progression if not already done.
  /// Deferred to after build via addPostFrameCallback to avoid modifying
  /// providers during the widget tree build phase.
  void _maybeAutoGenerateDefaults(ChordScaleFingeringsModel data) {
    if (_hasAutoGeneratedDefaults) return;
    _hasAutoGeneratedDefaults = true;

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _populateDefaultProgression(data);
    });
  }

  /// Populates the sequence with a default progression for the current scale/mode.
  /// Follows the same pattern as _loadProgression: clear → delay → update.
  void _populateDefaultProgression(ChordScaleFingeringsModel data) {
    final defaultChords = DefaultProgressionGenerator.generate(data);
    if (defaultChords.isEmpty) {
      if (mounted) setState(() { _isPreparingSequence = false; });
      return;
    }

    debugPrint('[PlayerPage] Auto-generating ${defaultChords.length} default chords '
        'for ${data.scaleModel?.scale} ${data.scaleModel?.mode}');

    // Clear any stale chords from a previous session
    ref.read(selectedChordsProvider.notifier).removeAll();

    // Update beat counter
    final totalBeats = defaultChords.fold<int>(0, (sum, c) => sum + c.duration);
    ref.read(beatCounterProvider.notifier).update((state) => totalBeats);

    // Delay to let the clear propagate, then inject default chords
    Future.delayed(const Duration(milliseconds: 150), () {
      if (!mounted) return;
      ref.read(selectedChordsProvider.notifier).updateProgression(defaultChords);
      if (mounted) setState(() { _isPreparingSequence = false; });
    });
  }
  
  Future<void> _loadProgression(ProgressionModel progression) async {
    try {
      debugPrint('[PlayerPage] Loading progression: ${progression.name} with ${progression.chords.length} chords');
      
      // CRITICAL: Stop any current playback before loading new progression
      final sequencerManager = ref.read(sequencerManagerProvider);
      final isCurrentlyPlaying = ref.read(isSequencerPlayingProvider);
      
      if (isCurrentlyPlaying && sequencerManager.sequence != null) {
        debugPrint('[PlayerPage] Stopping current playback before loading new progression');
        try {
          await sequencerManager.handleStop(sequencerManager.sequence!);
          ref.read(isSequencerPlayingProvider.notifier).state = false;
          // Small delay to ensure sequencer has fully stopped
          await Future.delayed(const Duration(milliseconds: 100));
        } catch (e) {
          debugPrint('[PlayerPage] Error stopping playback: $e');
        }
      }
      
      // Validate progression data
      if (progression.chords.isEmpty) {
        debugPrint('[PlayerPage] ERROR: Progression has no chords');
        return;
      }
      
      // Validate each chord has required data
      for (int i = 0; i < progression.chords.length; i++) {
        final chord = progression.chords[i];
        if (chord.completeChordName?.isEmpty ?? true) {
          debugPrint('[PlayerPage] ERROR: Chord $i has invalid name: ${chord.completeChordName}');
          return;
        }
        if (chord.selectedChordPitches?.isEmpty ?? true) {
          debugPrint('[PlayerPage] ERROR: Chord $i has no pitches: ${chord.selectedChordPitches}');
          return;
        }
      }
      
      // Check if widget is still mounted before proceeding
      if (!mounted) {
        debugPrint('[PlayerPage] Widget not mounted, aborting progression load');
        return;
      }
      
      // Clear existing chords first
      ref.read(selectedChordsProvider.notifier).removeAll();
      
      // Update scale context based on the first chord
      final firstChord = progression.chords.first;
      debugPrint('[PlayerPage] Setting scale context from first chord: ${firstChord.parentScaleKey} ${firstChord.scale} ${firstChord.mode}');
      
      // Update scale providers to match the progression
      ref.read(topNoteProvider.notifier).update((state) => firstChord.parentScaleKey);
      ref.read(scaleDropdownValueProvider.notifier).update((state) => firstChord.scale);
      ref.read(modeDropdownValueProvider.notifier).update((state) => firstChord.mode);
      
      // Update beat counter to match progression total beats
      final totalBeats = progression.totalBeats;
      debugPrint('[PlayerPage] Setting beat counter to: $totalBeats');
      ref.read(beatCounterProvider.notifier).update((state) => totalBeats);
      
      // Add a small delay to ensure the clear operation and scale updates complete
      Future.delayed(const Duration(milliseconds: 150), () {
        // Double-check widget is still mounted before proceeding with async operation  
        if (!mounted) {
          debugPrint('[PlayerPage] Widget unmounted during async load, aborting');
          return;
        }
        
        try {
          // Log progression details with null safety
          for (final chord in progression.chords) {
            debugPrint('[PlayerPage] Loaded chord: ${chord.completeChordName ?? "Unknown"}');
            debugPrint('[PlayerPage] Chord notes: ${chord.chordNotesInversionWithIndexes}');
          }
          
          // Add all chords at once using updateProgression to avoid multiple reinitializations
          ref.read(selectedChordsProvider.notifier).updateProgression(progression.chords);

          // Force a rebuild and dismiss loading overlay
          if (mounted) {
            setState(() { _isPreparingSequence = false; });
          }
        } catch (e, stackTrace) {
          debugPrint('[PlayerPage] ERROR during delayed progression loading: $e');
          debugPrint('[PlayerPage] Stack trace: $stackTrace');
        }
      });
    } catch (e, stackTrace) {
      debugPrint('[PlayerPage] ERROR loading progression: $e');
      debugPrint('[PlayerPage] Stack trace: $stackTrace');
    }
  }
  
  // Helper method to clean up resources - but preserve user data
  Future<void> _cleanupResources() async {
    // Prevent multiple cleanup calls
    if (_isCleaningUp || _isDisposed) {
      debugPrint('[PlayerPage] Cleanup already in progress or disposed, skipping');
      return;
    }
    
    _isCleaningUp = true;
    debugPrint('[PlayerPage] Cleaning up resources...');
    
    try {
      final sequencerManager = ref.read(sequencerManagerProvider);
      
      // Stop the sequencer if it's playing
      final isPlaying = ref.read(isSequencerPlayingProvider);
      if (isPlaying && sequencerManager.sequence != null) {
        debugPrint('[PlayerPage] Stopping sequencer during cleanup');
        await sequencerManager.handleStop(sequencerManager.sequence!);
        ref.read(isSequencerPlayingProvider.notifier).state = false;
      }
      
      // IMPORTANT: Don't clear chords! User data should persist across navigation
      // ref.read(selectedChordsProvider.notifier).removeAll(); // REMOVED - this was the bug!
      
      debugPrint('[PlayerPage] Cleanup completed');
    } catch (e, st) {
      debugPrint('[PlayerPage] Error during cleanup: $e\n$st');
    } finally {
      _isCleaningUp = false;
    }
  }

  @override
  void dispose() {
    if (!_isDisposed) {
      debugPrint('[PlayerPage] dispose called');
      _isDisposed = true;
      // _cleanupResources() REMOVED: Do not use ref after dispose
    }
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    debugPrint('[PlayerPage] build called');
    final fingerings = ref.watch(chordModelFretboardFingeringProvider);
    final sequencerManager = ref.read(sequencerManagerProvider);
    debugPrint('[PlayerPage] sequencerManager.sequence: \\${sequencerManager.sequence}');
    // debugPrint('[PlayerPage] fingerings state: \\${fingerings}');

    // PopScope for back button handling
    return PopScope(
      onPopInvokedWithResult: (didPop, result) {
        if (didPop) {
          debugPrint('[PlayerPage] PopScope triggered - cleanup handled by back button');
          // Note: cleanup is handled by the back button onPressed to avoid double cleanup
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: const PlayerPageTitle(),
          leading: IconButton(
            icon: const Icon(Icons.arrow_back_ios, color: Colors.white),
            onPressed: () async {
              debugPrint('[PlayerPage] Back button pressed');
              await _cleanupResources();
              // Let cleanup settle before starting the slide animation
              await Future.delayed(const Duration(milliseconds: 80));
              if (context.mounted) {
                Navigator.pushReplacement(
                  context,
                  SlideRoute(page: const SelectionPage(), direction: SlideDirection.fromLeft),
                );
              }
            },
          ),
          actions: [
            Consumer(
              builder: (context, ref, child) {
                final canSaveProgressions = ref.watch(featureRestrictionProvider('save_progressions'));

                return IconButton(
                  onPressed: () async {
                    // Show paywall for free users
                    if (!canSaveProgressions) {
                      Navigator.push(
                        context,
                        SlideRoute(page: const UnifiedPaywall(), direction: SlideDirection.fromBottom),
                      );
                      return;
                    }

                    // Stop any current playback before navigating to library
                    final sequencerManager = ref.read(sequencerManagerProvider);
                    final isCurrentlyPlaying = ref.read(isSequencerPlayingProvider);

                    if (isCurrentlyPlaying && sequencerManager.sequence != null) {
                      debugPrint('[PlayerPage] Stopping playback before navigating to library');
                      try {
                        await sequencerManager.handleStop(sequencerManager.sequence!);
                        ref.read(isSequencerPlayingProvider.notifier).state = false;
                      } catch (e) {
                        debugPrint('[PlayerPage] Error stopping playback: $e');
                      }
                    }

                    // Let cleanup settle before starting the slide animation
                    await Future.delayed(const Duration(milliseconds: 80));
                    if (context.mounted) {
                      Navigator.pushReplacement(
                        context,
                        SlideRoute(page: const ProgressionLibraryPage(), direction: SlideDirection.fromRight),
                      );
                    }
                  },
                  icon: Icon(
                    Icons.library_music,
                    color: canSaveProgressions ? Colors.white : Colors.grey,
                  ),
                );
              },
            ),
            IconButton(
              onPressed: () async {
                debugPrint('[PlayerPage] Forward button pressed');
                
                // Update fingerings if available - do this immediately
                final fingeringsValue = fingerings.value;
                if (fingeringsValue != null && fingeringsValue.scaleModel != null) {
                  if (fingeringsValue.scaleModel!.scaleNotesNames.take(5).any((s) => s.contains('♭'))) {
                    ref.read(sharpFlatSelectionProvider.notifier).update((state) => FretboardSharpFlat.flats);
                  }
                  // Update fretboardPageFingeringsProvider safely
                  ref.read(fretboardPageFingeringsProvider.notifier).update(fingeringsValue);
                }

                // Cleanup sequencer but preserve user chords
                await _cleanupResources();
                // Let cleanup settle before starting the slide animation
                await Future.delayed(const Duration(milliseconds: 80));
                if (context.mounted) {
                  Navigator.of(context).push(SlideRoute(
                      page: const FretboardPage(), direction: SlideDirection.fromRight));
                }
              },
              icon: const Icon(Icons.arrow_forward_ios,
                  color: Colors.orangeAccent),
            ),
          ],
        ),
        bottomNavigationBar: const BannerAdWidget(),
        body: SafeArea(
          child: Stack(
            children: [
              // Main content — deferred until slide transition completes
              if (!_isTransitionComplete)
                const SizedBox.shrink()
              else
                fingerings.when(
                  data: (data) {
                    debugPrint('[PlayerPage] fingerings.when: data received');
                    // Defensive: Check for nulls in data, scaleModel, and settings
                    if (data == null || data.scaleModel == null || data.scaleModel!.settings == null) {
                      debugPrint('[PlayerPage] Error: Missing data, scaleModel, or settings.');
                      return const Center(child: Text('Missing player data. Please check your selection.'));
                    }
                    // Auto-generate default progression on first data resolve
                    _maybeAutoGenerateDefaults(data);

                    return Column(
                      mainAxisAlignment: MainAxisAlignment.spaceAround,
                      children: [
                        SizedBox(height: MediaQuery.of(context).size.width > 600 ? 60 : 30),
                        Builder(
                          builder: (context) {
                            final isTablet = MediaQuery.of(context).size.width > 600;
                            return Padding(
                              padding: EdgeInsets.symmetric(
                                horizontal: isTablet ? 20 : 0,
                              ),
                              child: Center(
                                child: Transform.scale(
                                  scale: isTablet ? 1.44 : 1.0,
                                  child: Fretboard(),
                                ),
                              ),
                            );
                          },
                        ),
                        Expanded(
                          flex: 6,
                          child: Center(
                            child: Builder(
                              builder: (context) {
                                final isTablet = MediaQuery.of(context).size.width > 600;
                                return Transform.scale(
                                  scale: isTablet ? 1.2 : 1.0,
                                  child: const Chords(),
                                );
                              },
                            ),
                          ),
                        ),
                        Expanded(
                          flex: 8,
                          child: Builder(
                            builder: (context) {
                              debugPrint('[PlayerPage] Building PlayerWidget');
                              if (data.scaleModel != null && data.scaleModel!.settings != null) {
                                return PlayerWidget(data.scaleModel!.settings!);
                              } else {
                                return const Center(child: Text('Error: Missing settings.'));
                              }
                            },
                          ),
                        ),
                        const SizedBox(height: 32),
                      ],
                    );
                  },
                  loading: () {
                    debugPrint('[PlayerPage] fingerings.when: loading');
                    return const SizedBox.shrink();
                  },
                  error: (error, stackTrace) {
                    debugPrint('[PlayerPage] fingerings.when: error: $error');
                    return Center(child: Text('Error: $error'));
                  },
                ),
              // Loading overlay — fades out once sequence is prepared
              AnimatedOpacity(
                opacity: _isPreparingSequence ? 1.0 : 0.0,
                duration: const Duration(milliseconds: 400),
                child: IgnorePointer(
                  ignoring: !_isPreparingSequence,
                  child: Container(
                    color: AppColors.background,
                    child: Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const CircularProgressIndicator(color: Colors.orangeAccent),
                          const SizedBox(height: 20),
                          Text(
                            'Preparing your sequence...',
                            style: TextStyle(
                              color: Colors.white.withValues(alpha: 0.7),
                              fontSize: 15,
                              fontWeight: FontWeight.w400,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
